#+title: Setting up projects
#+author: Aaron Kunde
#+email: aaron.kunde@web.de
A collection of shell scripts, to set up work projects. The primary focus are projects for developing software, but can be anything. These scripts deal with tasks, like
- setting up the programming environment (e.g. a Java SDK) and
- setting up build tools, like Apache Maven or Gradle.

The scripts shall fulfill several tasks:

* Installation of software
- Check, if software is already installed in a given version.
- Download the software in that version, if not installed.
- Extract (install) the downloaded software to ~â€‹~/opt/~, if not installed.

* Setting up the environment
- Set necessary environment variables in the shell to use the the tools in the given version.
- Switch between versions of the same environment, without starting a new shell.

* Requirements
- The scripts must be usable from an interactive shell.
- The scripts should not be specific to certain shell implementations. Still, the current supported shell is [[https://www.gnu.org/software/bash/][GNU Bash]].
- The scripts must be usable as a dependency for other scripts (e.g first setting up a JDK and then Gradle).

* Usage
The best way, to use the scripts, is by including them using ~source~ or ~.~:
#+begin_src shell
  . /path/to/<setup-script>
#+end_src

** Usage options
The following methods of using the scripts have been evaluated:
- [[Execution in a shell][Execution in a shell]]
- [[Inclusion in the current shell][Inclusion in the current shell]]
- [[Using as init file][Using as init file]]

*** Execution in a shell
Executing a script in a shell, executes it in a [[https://tldp.org/LDP/abs/html/subshells.html][subshell]]. This does not export variables in the current (parent) shell, because [[https://tldp.org/LDP/abs/html/gotchas.html#PARCHILDPROBREF][variables are only exported in subshells]]. Therefore this method is not suitable.

*** Inclusion in the current shell
Including the script into the current shell, using ~source~ or ~.~ exposes all variables into the current shell or script, because no subshells are created. But it comes with some pitfalls, which have to be considered:

- If the [[https://tldp.org/LDP/abs/html/options.html][bash option]] ~-e~ is set in the script or one of its dependencies, it also closes the current shell, if an error occurs.

- Inclusion of other scripts doesn't work well with relative paths. This leads to errors if referencing dependencies with relative paths. Considering two scripts:
  - ~foo.sh~:
  #+begin_src shell :tangle foo.sh 
    #!/bin/sh

    echo "foo: $0, $(dirname 0)"
  #+end_src
  - ~bar.sh~:
  #+begin_src shell :tangle bar.sh 
    #!/bin/sh

    . foo.sh

    echo "bar: $0, $(dirname 0)"
  #+end_src
  While the inclusion from the same directory, where the scripts are, works fine
  #+begin_example
    ~/work/setup-project $ . bar.sh 
    foo: -bash, .
    bar: -bash, .
  #+end_example
  it does not, if the scripts are included from a different directory:
  #+begin_example
    ~/work$ . setup-project/bar.sh
    -bash: foo.sh: No such file or directory
    bar: -bash, .
  #+end_example

- /getopts/ doesn't work properly for repeated calls without resetting ~$OPTIND~
  
*** Using as init file
Creating a new subshell, Using the script as init file with
#+begin_example
  bash --init-file /path/to/<setup-script> [-i]
#+end_example
sets variables regardless of exports. It also ignores the file ~~/.bashrc~.


* Scripts
A basic [[file:template.org][template]] is defined, which is used as an abstract base for scripts for specific software.
